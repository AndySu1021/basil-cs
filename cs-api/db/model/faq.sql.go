// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: faq.sql

package model

import (
	"context"
	"time"

	"cs-api/internal/types"
)

const createFAQ = `-- name: CreateFAQ :exec
INSERT INTO faq (question, answer, status, created_by, created_at, updated_by, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateFAQParams struct {
	Question  string       `db:"question" json:"question"`
	Answer    string       `db:"answer" json:"answer"`
	Status    types.Status `db:"status" json:"status"`
	CreatedBy int64        `db:"created_by" json:"created_by"`
	CreatedAt time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt time.Time    `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateFAQ(ctx context.Context, arg CreateFAQParams) error {
	_, err := q.exec(ctx, q.createFAQStmt, createFAQ,
		arg.Question,
		arg.Answer,
		arg.Status,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	return err
}

const deleteFAQ = `-- name: DeleteFAQ :exec
DELETE
FROM faq
WHERE id = ?
`

func (q *Queries) DeleteFAQ(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteFAQStmt, deleteFAQ, id)
	return err
}

const getFAQ = `-- name: GetFAQ :one
SELECT question, answer, status
FROM faq
WHERE id = ? LIMIT 1
`

type GetFAQRow struct {
	Question string       `db:"question" json:"question"`
	Answer   string       `db:"answer" json:"answer"`
	Status   types.Status `db:"status" json:"status"`
}

func (q *Queries) GetFAQ(ctx context.Context, id int64) (GetFAQRow, error) {
	row := q.queryRow(ctx, q.getFAQStmt, getFAQ, id)
	var i GetFAQRow
	err := row.Scan(&i.Question, &i.Answer, &i.Status)
	return i, err
}

const listAvailableFAQ = `-- name: ListAvailableFAQ :many
select question, answer
from faq
where status = 1
`

type ListAvailableFAQRow struct {
	Question string `db:"question" json:"question"`
	Answer   string `db:"answer" json:"answer"`
}

func (q *Queries) ListAvailableFAQ(ctx context.Context) ([]ListAvailableFAQRow, error) {
	rows, err := q.query(ctx, q.listAvailableFAQStmt, listAvailableFAQ)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAvailableFAQRow{}
	for rows.Next() {
		var i ListAvailableFAQRow
		if err := rows.Scan(&i.Question, &i.Answer); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFAQ = `-- name: UpdateFAQ :exec
UPDATE faq
SET question   = ?,
    answer     = ?,
    status     = ?,
    updated_by = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateFAQParams struct {
	Question  string       `db:"question" json:"question"`
	Answer    string       `db:"answer" json:"answer"`
	Status    types.Status `db:"status" json:"status"`
	UpdatedBy int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt time.Time    `db:"updated_at" json:"updated_at"`
	ID        int64        `db:"id" json:"id"`
}

func (q *Queries) UpdateFAQ(ctx context.Context, arg UpdateFAQParams) error {
	_, err := q.exec(ctx, q.updateFAQStmt, updateFAQ,
		arg.Question,
		arg.Answer,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
